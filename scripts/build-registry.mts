import { tmpdir } from "os"
import { existsSync, promises as fs } from "fs"
import path from "path"
import { rimraf } from "rimraf"
import {
  Registry,
  registrySchema,
} from "shadcn/registry"
import { Project, ScriptKind } from "ts-morph"

import { registry } from "../registry"

const REGISTRY_PATH = path.join(process.cwd(), "public/r")

const project = new Project({
  compilerOptions: {},
})

async function createTempSourceFile(filename: string) {
  const dir = await fs.mkdtemp(path.join(tmpdir(), "shadcn-"))
  return path.join(dir, filename)
}

async function buildRegistry(registry: Registry) {
  let index = `// @ts-nocheck
// This file is autogenerated by scripts/build-registry.ts
// Do not edit this file directly.

import * as React from "react"

export const Index: Record<string, any> = {
`
    // Build style index.
    for (const item of registry.items) {
      const resolveFiles = item.files?.map(
        (file) =>
          `registry/${
            typeof file === "string" ? file : file.path
          }`
      )
      if (!resolveFiles) {
        continue
      }

      const type = item.type.split(":")[1]
      let sourceFilename = ""

      if (item.type === "registry:block") {
        const file = resolveFiles[0]
        const filename = path.basename(file)
        let raw: string
        try {
          raw = await fs.readFile(file, "utf8")
        } catch (error) {
          console.error(
            `Failed to read file ${file} for item ${item.name}:`,
            error
          )
          continue
        }
        const tempFile = await createTempSourceFile(filename)
        const sourceFile = project.createSourceFile(tempFile, raw, {
          scriptKind: ScriptKind.TSX,
        })

        // Find all imports.
        const imports = new Map<
          string,
          {
            module: string
            text: string
            isDefault?: boolean
          }
        >()
        sourceFile.getImportDeclarations().forEach((node) => {
          // eslint-disable-next-line @next/next/no-assign-module-variable
          const module = node.getModuleSpecifier().getLiteralValue()
          node.getNamedImports().forEach((item) => {
            imports.set(item.getText(), {
              module,
              text: node.getText(),
            })
          })

          const defaultImport = node.getDefaultImport()
          if (defaultImport) {
            imports.set(defaultImport.getText(), {
              module,
              text: defaultImport.getText(),
              isDefault: true,
            })
          }
        })

        // Write the source file for blocks only.
        sourceFilename = `__registry__/${type}/${item.name}.tsx`

        if (item.files) {
          const files = item.files.map((file) =>
            typeof file === "string"
              ? { type: "registry:page", path: file }
              : file
          )
          if (files?.length) {
            sourceFilename = `__registry__/${files[0].path}`
          }
        }

        const sourcePath = path.join(process.cwd(), sourceFilename)
        if (!existsSync(sourcePath)) {
          await fs.mkdir(sourcePath, { recursive: true })
        }

        rimraf.sync(sourcePath)
        await fs.writeFile(sourcePath, sourceFile.getText())
      }

      let componentPath = `@/registry/${type}/${item.name}`

      if (item.files) {
        const files = item.files.map((file) =>
          typeof file === "string"
            ? { type: "registry:page", path: file }
            : file
        )
        if (files?.length) {
          componentPath = `@/registry/${files[0].path}`
        }
      }

      index += `\
    "${item.name}": {
      name: "${item.name}",
      description: "${item.description ?? ""}",
      type: "${item.type}",
      registryDependencies: ${JSON.stringify(item.registryDependencies)},
      files: [${item.files?.map((file) => {
        const filePath = `registry/${
          typeof file === "string" ? file : file.path
        }`
        const resolvedFilePath = path.resolve(filePath)
        return typeof file === "string"
          ? `"${resolvedFilePath}"`
          : `{
        path: "${filePath}",
        type: "${file.type}",
        target: "${file.target ?? ""}"
      }`
      })}],
      categories: ${JSON.stringify(item.categories)},
      component: React.lazy(() => import("${componentPath}")),
      source: "${sourceFilename}",
      meta: ${JSON.stringify(item.meta)},
    },`
    }

    index += `
  },`

  const items = registry.items
    .filter((item) => ["registry:ui"].includes(item.type))
    .map((item) => {
      return {
        ...item,
        files: item.files?.map((_file) => {
          const file =
            typeof _file === "string"
              ? {
                  path: _file,
                  type: item.type,
                }
              : _file

          return file
        }),
      }
    })
  const registryJson = JSON.stringify(items, null, 2)
  rimraf.sync(path.join(REGISTRY_PATH, "index.json"))
  await fs.writeFile(
    path.join(REGISTRY_PATH, "index.json"),
    registryJson,
    "utf8"
  )

  // Write style index.
  rimraf.sync(path.join(process.cwd(), "__registry__/index.ts"))
  await fs.writeFile(path.join(process.cwd(), "__registry__/index.ts"), index)
}


try {
  console.log("ðŸ’½ Building registry...")
  const result = registrySchema.safeParse(registry)

  if (!result.success) {
    console.error(result.error)
    process.exit(1)
  }

  await buildRegistry(result.data)

  console.log("âœ… Done!")
} catch (error) {
  console.error(error)
  process.exit(1)
}